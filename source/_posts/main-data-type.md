---
title: 常用数据结构
date: 2020-05-20 08:54:00
tags: Linux
---

> 数据结构

<!-- more -->


### 数组
1. 结构
- 以连续的地址，按照顺序存储元素，每个元素都有唯一下标。
![](/img/2020/data_type_one.png)

2. 优点
- 实现简单，使用便捷
- 下标是唯一索引值，所以查询相对较快

3. 缺点
- 因为插入和删除时需要移动大量元素，所以增删操作效率较低
- C 语言中数组的有固定的空间，存在数据溢出的风险，旧式编程语言还会越界写到核心内存上。

4. 操作
- 增：如果是插入到中间位置，该位置后面的元素都要往后移动一位，所以效率较低
- 删：如果删除的元素在中间，该元素后面的元素都要往前移动一位，所以效率也低
- 查：通过下标访问
- 改：通过下标赋值


5. 场景
- 简单易用，多用于数据量小的场景
- 合适增删操作频率低，查询频率高的场景


### 链表
1. 结构
- 单向链表：一个 node 中包括两块内容，一块保存数据，另外一块保存下一个 node 的指针，多个 node 串在一起，形成链式结构

![](/img/2020/data_type_two.png)

- 双向链表：在单向链表的基础上，加多一个指针，指向上一个 node


![](/img/2020/data_type_three.png)


- 循环链表：在单向链表的基础上，将尾部的指针指向头部的 node

![](/img/2020/data_type_four.png)


2. 优点
- node 指针可自由指向下一个地址，元素无需按照顺序存储，所以插入和删除操作复杂度预计O(1)，比数组效率高
- 创建时无需指定链表大小，借助指针特性动态调整内存空间

3. 缺点
- 由于多保存了指针数据，所以空间开销会增大
- 链表查询一般从链头开始遍历，通过指针一层层查找，所以效率会比数组更低


4. 操作
- 增：插入到指定位置时，只需修改 node 的指针指向即可，效率较高
- 删：删除某个元素时，也只需修改 node 的指针指向即可
- 查：从链头开始遍历到链尾
- 改：只需修改 node 的数据部分

5. 场景
- 合适保存量不确定的数据
- 合适增删频率高，查询频率低的场景


### 散列表（哈希表）
1. 结构
- 利用哈希函数计算唯一键 Key，通过 key 访问指定内存位置的数据
- 好比查新华字典，通过拼音首字母"C"查找具体的汉字"陈"，效率会快点
![](/img/2020/data_type_five.png)

2. 优点
- 通过唯一 key 查询和修改数据，在大量数据情况下，复杂度依然在 O(1) 左右
- 数据存储是非连续的，所以增删数据时，只需操作本次数据，复杂度也在约为 O(1)

3. 缺点
- 设计哈希函数时需要考虑 key 冲突的可能性
- 由于经过了哈希函数转换，原始 key 值已经丢失
- 为了确保 key 不冲突，申请的存储空间会比实际数据大
- 数据存储是不连续的，所以难以排序，而且存在很多空挡


4. 操作
- 增：在唯一 key 的位置插入数据，复杂度O(1)
- 删：在唯一 key 的位置删除数据，复杂度O(1)
- 查：通过唯一 key 查询，复杂度O(1)
- 改：通过唯一 key 修改，复杂度O(1)

5. 场景
- 哈希表主要特点是增删改查都很快，接近O(1)，合适对增删改查都有性能要求的场景
- 哈希表在数组和链表之间取平衡策略，兼顾了链表的增删快的特点，以及数组的改查快的特点

6. 延伸
- 解决 key 冲突的方法
 - 采取开放寻址法，如果数据经过哈希函数后，得出的存储位置已被占用，则从当前位置开始，依次往后查找，看是否有空闲位置。 

![](/img/2020/data_type_six.png)

 - 采取哈希表+单项链表的数据结构，在相同 key 的位置，增加一条单向链表，以此保存多个数据
 
![](/img/2020/data_type_seven.png)


### 栈
1. 结构
- 数据按照后进先出（LIFO, Last In First Out）的原理运作
- 好比砌墙，先从底部开始放砖头，拆的时候则从头顶开始拆

![](/img/2020/data_type_8.png)

2. 优点
- 后进先出的特点
- 存取速度快

3. 缺点
- 栈的数据大小和生存期必须是确定的，缺乏灵活性。

4. 操作
- 入栈：push，添加到栈顶部
- 出栈：pop，从栈顶部移除

5. 场景
- 合适数据量小，后进先出的场景


![](/img/2020/data_type_9.png)


### 队列
1. 结构
- 按照先进先出（FIFO, First-In-First-Out）的线性表，通常用链表或者数组来实现。
- 好比排队吃饭，先来先吃，后来者排队依次等待

![](/img/2020/data_type_10.png)

2. 优点
- 先进先出的特点
- 存取速度快

3. 缺点
- 使用时需要确定数据空间大小

4. 操作
- 入队：从队头插入数据
- 出队：从队尾移除数据

5. 场景
- 合适数据量小，先进先出的场景


### 树

##### 1. 二叉树
- 定义
像倒过来的树一样的结构，结构会调整，每个节点数值也会调整，节点甚至会采用链表，以便满足各种场景。
![](/img/2020/data_type_12.png)


##### 2. 完美二叉树
- 定义
除了子节点外，所有父节点都必须填充，而且保持左右对称
![](/img/2020/data_type_13.png)


##### 3. 完满二叉树
- 定义
采用左对齐的填充方式，除了子节点外，所有父节点都必须填充，在堆排序中会用到

![](/img/2020/data_type_14.png)


##### 4. 完全二叉树
- 定义
除了子节点之外，所有父节点都有两个子节点

![](/img/2020/data_type_15.png)


##### 5. 二叉查找树
- 定义
主要通过节点数值大小和节点结构，实现快速的查找功能，实质是利用二分法查找，查找所需的最大次数等同于二叉查找树的高度。
- 特点
 - 若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。
 - 若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值。

![](/img/2020/data_type_16.png)

![](/img/2020/data_type_17.png)


##### 6. AVL树，高度平衡二叉树
- 定义
如果二叉查找树退化成链表，那么查找复杂度就跟链表一样O(n)，所以为了降低二叉树高度，就有了平衡二叉树的。

- 特点
 - 具有二叉查找树的全部特性。
 - 每个节点的左子树和右子树的高度差至多等于1。
 - 通过左旋和右旋的方式，将二叉查找树维持在平衡状态

![](/img/2020/data_type_18.png)

![](/img/2020/data_type_two.gif)

![](/img/2020/data_type_19.png)

![](/img/2020/data_type_one.gif)

![](/img/2020/data_type_20.png)


##### 7. 红黑树
- 定义：
因为 AVL 树为了维持平衡，需要多次旋转，即数据在插入、删除很频繁的场景中，非常影响性能，所以又有了红黑树的结构，它不会像 AVL 树一样频繁调整，红黑树在最坏情况下也能保持查找复杂度在 O(logn)


- 应用
Java中TreeSet HashMap等用了红黑树。



##### 8. B(B-)树
- 定义
B-tree树即B树，也译为B-树，B即Balanced，平衡的意思。
B树是一种多路搜索树，并不是二叉树，二叉树的查找时，树越高，复杂度也越高，而B树结构则通过增多子节点的方式，降低了树高度，达到提升查找性能的。
B树定义了一个阶数 m，表示父节点可拥有的子节点数。

- 特点
 - 每个结点最多有m-1个关键字。
 - 根结点最少可以只有1个关键字。
 - 非根结点至少有Math.ceil(m/2)-1个关键字。Math.ceil(m/2)含义是向上取整。例如Math.ceil(4.5) = 5。
 - 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
 - 所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

![](/img/2020/data_type_21.png)


- 应用
 - B树的查找其实是对二叉搜索树查找的扩展， 与二叉搜索树不同的地方是，B树中每个节点有不止一棵子树，所以需要遍历多个子树。
 - 树特点是矮而宽，即降低树的高度，以便提升查找效率。
 - 适合海量数据无法放入内存的情况，即每次加载一个节点数据，避免内存不足。



##### 9. B+树
- 定义
与 B 树类似，主要不同点如下：
 - B+树改进了B树, 让中间的非子节点只作索引使用, 去掉了其中指向 data record 的指针, 使得每个节点中能够存放更多的key。
 - 最底部的叶子结点是链表形式, 因此也可以实现更方便的顺序遍历。

- 特点
 - 因为非子节点能存放更多的key, 树的层高能进一步被压缩, 使得检索的时间更短。
 - 查找多个数据时，B树需要做局部的中序遍历，可能要跨层访问，而B+树由于所有数据都在叶子结点，不用跨层，同时由于子节点有链表结构，通过链表方便按照顺序把数据取出来了。

![](/img/2020/data_type_22.png)


- 应用
MySQL InnoDB 采用 B+树

#### 关于树选择的策略

![](/img/2020/data_type_11.png)
