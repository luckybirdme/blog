---
title: C10K
date: 2020-05-30 23:11:35
tags: Linux
---

> 单机1万个并发连接问题


<!-- more -->

## 一. 背景

##### 1. 互联网还不够普及，用户也不多。一台服务器同时在线100个用户估计在当时已经算是大型应用了。所以并不存在什么C10K的难题。

##### 2. 互联网的爆发期应该是在www网站，浏览器，雅虎出现后。最早的互联网称之为Web1.0，互联网大部分的使用场景是下载一个Html页面，用户在浏览器中查看网页上的信息。这个时期也不存在C10K问题。

##### 3. Web2.0时代到来后就不同了，一方面是普及率大大提高了，用户群体几何倍增长。另一方面是互联网不再是单纯的浏览万维网网页，逐渐开始进行交互，而且应用程序的逻辑也变的更复杂，从简单的表单提交，到即时通信和在线实时互动。C10K的问题才体现出来了。

##### 4. 每一个用户都必须与服务器保持TCP连接才能进行实时的数据交互。Facebook这样的网站同一时间的并发TCP连接可能会过亿。腾讯QQ也是有C10K问题的，只不过他们是用了UDP这种原始的包交换协议来实现的，绕开了这个难题。


##### 5. 如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook，Google，雅虎才有财力购买如此多的服务器。这就是C10K问题的本质。


## 二. 解决方法：IO多路复用 + 异步IO

##### 1. 原理
- 同一进程/线程来同时处理多个连接，即 IO 多路复用，此模式需要不停地轮询，如果有IO数据则返回，所以属于同步 IO，其优点只是能够在单进程/线程下，处理多个IO连接。
- 利用异步回调，当一个IO的特定事件比如可读发生时，自动执行用户指定的回调函数，不会阻塞主流程的执行，此过程也称为异步 IO。

##### 2. 方案
[libuv](https://github.com/libuv/libuv) 是采用 C 语言编写的跨平台异步IO类库，在Unix系统上，通过封装libev和libio调用 Linux 的 epoll 或 kqueue，在Windows 平台上的IOCP进行封装，实现异步 IO 和多路复用的功能。刚开始是为了 nodejs 编写的，目前已经别其他组件使用了。

## 三. 解决方法：协程，用户态切换

##### 1. 原理
- IO 多路复用存在用户态和内核态切换上下文时，对性能有一定损耗，尤其是在大并发的情况尤为明显。
- 将数据包处理，内存管理，处理器调度等任务从内核转移到应用程序高效地完成，让内核只处理简单的硬件交互，数据层完全交给应用程序来处理。
- 进程和线程的切换需要内核态参与，所以希望有更轻量的处理单元，不需要内核参与，在用户态就能自如切换，而协程就是这样的轻量级处理单元。
- 在线程执行多个任务时，一旦某个任务阻塞，则可能在同一线程中，继续运行其他任务，此时切换的协程处理单元，避免线程的大量上下文的切换。
- 每个协程所独占的系统资源往往只有栈部分。而且各个协程之间的切换，往往是用户通过代码来显式指定的，不需要内核参与，切换成本低。

##### 2. 方案
- Python、Lua 语言中的 coroutine（协程）模型
- Go 语言中的 goroutine（Go 协程）模型

## 四. 异步回调和协程对比
协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换。
所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。
而异步回调是没有切换开销的，它等同于顺序执行代码。
所以异步回调程序的性能是要优于协程模型的。