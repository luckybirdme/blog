---
title: 进程、线程、协程切换过程
date: 2020-07-11 22:17:48
tags: Linux
---

> 切换

<!-- more -->


## 一. 概念介绍

1. CPU，全名Central Processing Unit（中央处理器）
这是一块超大规模的集成电路，包含上亿的晶体管，是一台计算机的运算核心（Core）和控制核心（ControlUnit）。
它的功能主要是解释计算机指令以及处理计算机软件中的数据，主要构成是：运算器、控制器、寄存器

- 运算器：可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。
- 控制器：主要是负责对指令译码，并且发出为完成每条指令所要执行的各个操作的控制信号。其结构有两种：一种是以微存储为核心的微程序控制方式；一种是以逻辑硬布线结构为主的控制方式。
- 寄存器：寄存器部件，包括寄存器、专用寄存器和控制寄存器。通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。


2. 寄存器
每个 CPU 都包括一套单独的寄存器，因此每个 CPU 可以运行一个进程，多个 CPU 就能并发多个进程。
寄存器主要分类包括：

- 累加寄存器：存储执行运算的数据和运算后的数据。
- 标志寄存器：存储运算处理后的CPU的状态。
- 程序计数器：存储下一条指令所在内存的地址。
- 基址寄存器：存储数据内存的起始地址。
- 变址寄存器：存储基址寄存器的相对地址。
- 通用寄存器：存储任意数据。
- 指令寄存器：存储指令。CPU内部使用，程序员无法通过程序对该寄存器进行读写操作。
- 栈寄存器：存储栈区域的起始地址。

其中，程序计数器，累加寄存器，标志寄存器，指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。


3. 程序计数器，决定 CPU 执行指令的流程
- 地址0100是程序运行的开始位置。操作系统把程序从硬盘复制到内存后，会将程序计数器（CPU寄存器的一种）设定为0100，然后程序开始运行。
- CPU每执行一个指令，程序计数器的值就会自动加1。例如，CPU执行0100地址的指令后，程序计算器的值就变成0101（当执行的指令占据多个内存地址时，增加与指令长度相应的数值）。
- CPU的控制器会参照程序计数器的数值，从内存中读取命令并执行，也就是说，程序计数器决定着程序的流程。

![](/img/2020/linux_p_t_c.jpg)


4. 虚拟内存
- 虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存。
- 进程的数据必然要放到物理内存上，必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，也就是虚拟内存地址与物理内存地址的映射关系。
- 操作系统通过页表中记录了虚拟内存地址到物理内存地址的映射关系，有了页表就可以将虚拟地址转换为物理内存地址了，这种机制就是虚拟内存。
- 每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。

5. TLB（Translation Lookaside Buffer）
- 页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。
- 为了减少因为MMU导致的处理器性能下降，引入了TLB，可翻译为“地址转换后援缓冲器”，也可简称为“快表”。
- 简单地说，TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。
- 只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。



## 二. 切换过程 

1. 进程切换

内核利用 CPU 时间分片执行不同进程，触发进程切换
切换过程：
- 页表切换，此时 TLB 可能会失效，导致读取性能下降
- 硬件上下切换，比如 CPU 主要寄存器，状态寄存器，程序计数器等


![](/img/2020/linux_p_t_c_1.jpg)


2. 线程切换

不同进程的不同线程切换，跟不同进程切换过程一样。
同一个进程内，线程共享页表，这是并发线程出现资源抢占的原因。
正因为共享页表，所以进程内的线程切换不需要切换页表，相比进程切换成本更低。
线程是系统调用的最小单元，多个线程也是根据 CPU 时间分片执行，也是由内核进行切换。
切换过程：
- 硬件上下切换，比如 CPU 主要寄存器，状态寄存器，程序计数器等


3. 协程切换

协程切换无需内核参与，在用户态又用户程序就能实现切换。
协程切换的寄存器非常少，比较线程的 thread_strcut 和协程的 coroutine_struct 结构体大小就能明显区分出来。
切换过程：
- 硬件上下切换，只涉及极少的寄存器，因此切换成本最低



## 五. 切换区别

切换|进程|线程|协程
-|-|-|-
页表|需要切换，可能导致TLB失效|进程内的线程共用页表，所以不用切换|不用 
寄存器|当前CPU的寄存器都要切换|切换部分寄存器|只需切换极少寄存器，因此成本最低
内核参与|通过内核实现切换|通过内核实现切换|无需内核参与，用户态就能切换，因此成本很低
