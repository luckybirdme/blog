---
title: JS 求最长上升子序列的长度
date: 2019-10-26 08:34:44
tags: algorithm
---

> 已知有数列 A ， A=A1,A2....An ，求 A 的任意子序列 B （ B=Ak1,Ak2....Akp ），使 B 满足 k1<k2<....<kp 且 Ak1<Ak2<....<Akp 。现求 p 的最大值，即最长上升子序列的长度。

<!-- more -->


## 前言
##### 1. 最长上升子序列
```
已知有数列 A ， A=A1,A2....An ，求 A 的任意子序列 B （ B=Ak1,Ak2....Akp ），使 B 满足 k1<k2<....<kp 且 Ak1<Ak2<....<Akp 。现求 p 的最大值，即最长上升子序列的长度
```


##### 2. 具体数组例子
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```


## 正文

### 一. 时间复杂度 O(n^2)
##### 1. 解决思路
- 先求出数组每个元素当前位置的最长上升子序列的长度。
- 所有元素的最长上升子序列逐一对比，获得最大值，即为数组的最长上升子序列的长度。

##### 2. 分析过程
以数组 A [10,9,2,5,3,7,101,18] 为例，dp 存放每个位置的最长上升子序列的长度：
```
A[0]=10，下标 0 位置的最长上升子序列为 [10]，长度 为 dp[0]=1；
A[1]=9，下标 1 位置的最长上升子序列为 [9]，长度 为 dp[1]=1；
A[2]=2，下标 2 位置的最长上升子序列为 [2]，长度 为 dp[2]=1；
A[3]=5，下标 3 位置的最长上升子序列为 [2,5]，长度 为 dp[3]=2；
A[4]=3，下标 4 位置的最长上升子序列为 [2,5] 或者 [2,3]，长度为 dp[4]=2；
A[5]=7，下标 5 位置的最长上升子序列为 [2,5,7] 或者 [2,3,7]，长度为 dp[5]=3；
A[6]=101，下标 6 位置的最长上升子序列为 [2,5,7,101] 或者 [2,3,7,101]，长度为 dp[6]=4；
A[7]=18，下标 7 位置的最长上升子序列为 [2,5,7,101] 或者 [2,5,7,18] 或者 [2,3,7,101] 或者 [2,3,7,18]，长度为 dp[7]=4；
```
那么数组 A 最长上升子序列的长度就为 4。
从以上分析可看出，数组 A 的 i 位置的最长子序列为 dp[i]， 当 A[i+1] > A [i] 时，那么 dp[i+1]=dp[i] + 1；
由此可采取递推的方式，先求出 dp[0]，然后判断 A[1] > A[0]，继而求出 dp[1]，再算 dp[2]，一直递推到数组结尾，即可获得数组每个元素当前位置的最长子序列的长度。


##### 3. 代码实现
```js
// 算法复杂度 O(n^2)
function lengthOfLIS(nums) {
    // 保存数组每个元素当前位置的最长上升子序列的长度
    var dp = []
    // 整个数组中，最长的上升子序列的长度
    var max = 0;
    // 遍历数组每个元素，求出每个元素的最长上升子序列的长度
    for(var i=0;i<nums.length;i++){
        // 默认每个元素的最长上升子序列的长度为 1，即本身
        dp[i] = 1;
        // 该元素跟之前的元素比较
        // 如果较大，那该元素的最长上升子序列的长度，比之前元素的最长上升子序列的长度加 1
        for(var j=0;j<i;j++){
            if(nums[j]<nums[i]){
                dp[i] = Math.max(dp[i],dp[j]+1);
            }
        }
        // 获取数组最大的上升子序列的长度
        max = Math.max(dp[i],max);
    }
    return max;
};
```


### 二. 时间复杂度  O(nlogn)
##### 1. 解决思路
- 从上面的解决方法可知，求数组最长上升子序列的长度，关键记住最长上升子序列的最小末尾数和当前的序列长度。
- 用数组 dp 保存最长上升子序列的最小末尾数，如果后续数值 val > dp[dp.length-1] ，则直接追加到数组。
- 如果有更小的数值 val，查找数组满足 dp[i-1]< val <= dp[i]，并替换 dp[i]=val，以便保存后续有从 val 开始递增的数值。
- 此时数组 dp 的长度就是最长上升子序列的长度，但是数组元素排列不一定就是最长上升子序列。

##### 2. 分析过程
以数组 A [10,9,2,5,3,7,101,18] 为例，dp 存放上升子序列，不一定是最长上升子序列：
```
A[0]=10，默认 dp[0]=10，即dp=[10]；
A[1]=9，dp 保存上升子序列的最小末尾数，所以进行替换 dp[0]=A[1]，变成 dp=[9]；
A[2]=2，继续替换，dp[0]=A[2]，变成 dp=[2]；
A[3]=5，根据 val > dp[dp.length-1]，此时满足 A[3] > dp[0]，所以追加到 dp，变成 dp=[2,5]；
A[4]=3，根据 dp[i-1]< val <= dp[i]，此时满足 dp[0]< A[4]<= dp[1]，所以进行替换，dp[1]=A[4]=3，变成 dp=[2,3] ；
A[5]=7，根据 val > dp[dp.length-1]，此时满足 A[5] > dp[1]，所以追加到 dp，变成 dp=[2,3,7]；
A[6]=101，根据 val > dp[dp.length-1]，此时满足 A[6] > dp[0]，所以追加到 dp，变成 dp=[2,3,7,101]；
A[7]=18，根据 dp[i-1]< val <= dp[i]，此时满足 dp[2]< A[7]<= dp[3]，所以进行替换，dp[3]=A[7]=18，变成 dp=[2,3,7,18] ；
```
那么数组 A 最长上升子序列的长度就为 dp.length = 4。
再次强调，dp 保存是最长上升序列的最小末尾数，但不一定是最长上升序列。
如果次数数组 A 变成 [10,9,2,5,3,7,101,18,4]，那么 dp 将会是 [2,3,4,18]，但是最长上升子序列是依然是 [2,5,7,101] 或者 [2,5,7,18] 或者 [2,3,7,101] 或者 [2,3,7,18]，并没有包括数值 4。
在查找数组满足提交 dp[i-1]< val <= dp[i] 时，可通过二分法查找，所以算法时间复杂度是 logn，整体复杂度变成 O(nlogn)。


##### 3. 代码实现 
```js
// 算法复杂度 O(logn)
function lengthOfLISBetter(arr){
    // 保存最长上升子序列的末尾数，不一定是最长上升子序列
    var dp=[];
    var len = arr.length;
    // 用于二分查找，把最长上升子序列的末尾数替换到序列中
    var dp_start=0;
    var dp_end=0;
    var dp_mid=0;
    // 默认第一个参数为最长上升子序列的末尾数
    dp[0]=arr[0];
    for(var i=1;i<len;i++){
        dp_end=dp.length-1;

        // 如果数值大于最长上升子序列的末尾数，则直接追加
        //console.log('arr :',i,arr[i]);
        if(arr[i]>dp[dp_end]){
            dp.push(arr[i]);
            //console.log('dp add:',dp);
        // 如果数值小于或等于末尾数，则替换满足 dp[j-1]<arr[i]<=dp[j] 条件的 dp[j]
        }else{
            // 从 dp 数组开头查找
            dp_start=0;
            while(dp_end>dp_start){
                //console.log('start:',dp_start,dp_end);
                // 二分法查找
                dp_mid=Math.floor((dp_end+dp_start)/2);
                
                //console.log('mid:',dp_mid,dp[dp_mid]);

                // 出现相同的数值，直接跳过查找
                if(arr[i]==dp[dp_mid]){
                    dp_end=dp_mid;
                    break;
                }
                if(arr[i]>dp[dp_mid]){
                    dp_start=dp_mid+1;
                }else{
                    dp_end=dp_mid;
                }

                //console.log('end:',dp_start,dp_end);
            }
            
            // 替换
            dp[dp_end]=arr[i];
            //console.log('dp replace:',dp);
        }

        
    }
    // console.log(dp);
    // 获得最长上升子序列的长度
    return dp.length;

}
```

### [源代码](/example/js/length-of-LIS.html)