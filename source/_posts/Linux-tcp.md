---
title: TCP/UDP 协议
date: 2020-04-21 08:59:51
tags: Linux
---

> TCP 
> UDP

<!-- more -->


## 一. OSI 模型

1. 根据 OSI 模型，两个应用之间通信需要通过传输层，网络层，物理层；
2. 物理层是物理硬件，比如光纤，网线等，将 01 的状态通过载波传输到指定 MAC 地址。
3. 网络层的核心是 IP 协议，它将数据打包成 IP 数据报，通过数据分组和路由转发到指定 IP 地址。
4. IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包，需要发现丢了哪个包，以及重新发送这个包，此时就得依靠传输层的 TCP 协议。TCP 协议的主要作用是保证数据通信的完整性和可靠性，防止丢包。
5. 传输层主要协议包括 TCP 和 UDP，两者各有特性，合适不同的场景。

![](/img/2020/TCP_IP.png)


## 二. TCP 和 UDP 协议

#### 1. 主要区别

区别| TCP | UDP
-|-|-
定义|Transmission Control Protocol，传输控制协议|User Data Protocol，用户数据报协议
连接|必须先建立连接，即三次握手，才能发送数据|不需要建立连接，就能直接发送数据
模式|只能两个端点之间一对一地通信|支持一对一，一对多，多对一，多对多
可靠|提供可靠的交付服务，传输数据无差错，不丢失，不重复，且按时序到达|使用尽最大努力交付，但是不保证数据完整，有序。
数据|面向字节流，根据需要将数据拆分和合并后再发送|面向报文，一次就发送一个完整的报文
流量|有流量控制，根据网络情况调整数据传输速率|尽最大努力将应用程序的数据传输到网络上
通道|双向同时通信，即两端之间能互发信息|单向，比如客户端单向发送信息给服务端
头部|首部有20个字节 |首部开销小，只有8字节
主体|IP 报文长度 - 20 byte(IP 首部) - 20 byte(TCP 首部)|IP 报文长度 - 20 byte(IP 首部) - 8 byte(UDP 首部)



![](/img/2020/TCP_one.png)

![](/img/2020/UDP_one.gif)



#### 2. 使用场景
- TCP协议是基于连接的可靠协议，有流量控制和差错控制，也正因为有复杂的控制手段，所以传输效率比UDP低，合适对数据有准确性要求，效率不用太高的场景。
- UDP协议是基于无连接的不可靠协议，没有过多的控制和头部信息，只负责尽最快速度将数据发送，所以效率更高，合适容忍部分数据丢包，要求时效性较高的场景。


#### 4. TCP 用途
- 文件传输，FTP HTTP 对数据准确性要求高，速度可以相对慢
- 发送或接收邮件，POP IMAP SMTP 对数据准确性要求高，非紧急应用
- 远程登录，TELNET SSH 对数据准确性有一定要求，有连接的概念


#### 5. UDP 用途
- 在线视频，视频偶尔花了一个图像帧，人们还是能接受的
- 网络电话，语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题
- 音乐播放，音频数据准确性和丢包要求比较低，但速度必须快，主持人口音不同步


## 三. TCP 报文解析

![](/img/2020/TCP_two.png)


- 源端口号, Source Port
长度为16位，指明主机发送数据的进程端口。

- 目的端口号, Destination Port
长度为16位，指明目的主机接收数据的进程端口。 

- 序列号, Sequence Number
长度为32位，用来标识从发送端向接收端发送的字节数量，可以理解成对字节的计数，确保发送数据的完整且有序。

- 确认号, Acknowledgement Number
长度为32位，用来标识接收端所期望收到的下一个序列号，即发送端上次发送的序列号 + 字节数，以便发送端知道接收端收到了哪些数据，确保发送数据不会丢失。确认号只有在 ACK 标志位为1时才有效。

- 首部长度
长度为4位，用于表示TCP报文首部的长度，首部前20个字节是必有的，后40个字节可能有。如果TCP报文首部是20个字节，则该位应是20/4=5。

- 保留位, Reserved
长度为6位，必须是0，它是为将来定义新用途保留的。

- 标志位, Flags
长度为6位，在TCP报文中不管是握手还是挥手还是传数据等，这6位标志都很重要，从左到右依次为：
	1. URG：紧急标志位，说明紧急指针有效；
	2. ACK：确认标志位，多数情况下空，说明序列号有效；
	3. PSH：推送标志位，置位时表示接收方应立即请求将报文交给应用层；
	4. RST：复位标志位，用于重建一个已经混乱的TCP连接；
	5. SYN：同步标志位，仅在三次握手建立TCP连接时有效，表示要建立连接；
	6. FIN：结束标志位，用于结束一个TCP会话。

- 窗口大小, Window Size
长度为16位，TCP流量控制由连接的每一端通过声明的窗口大小来提供。

- 检验和, Checksum
长度为16位，该校验值计算方式覆盖整个TCP报文数据，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。

- 紧急指针, Urgent Pointer
长度为16位，指向数据中优先部分的最后一个字节，通知接收方紧急数据的长度，该字段在URG标志置位时有效。

- 选项, Options
长度为0-40个字节，必须以4个字节为单位变化，必要时可以填充 0，是TCP首部的扩展字段，不一定会有。

- 数据, data
具体传输的数据



## 四. UDP 报文解析

- 源端口号, Source Port
长度为16位，指明主机发送数据的进程端口。

- 目的端口号, Destination Port
长度为16位，指明目的主机接收数据的进程端口。

- UDP长度
长度为16位，该字段值为UDP首部和数据两部分的总字节数。

- 检验和, Checksum
长度为16位，UDP 数据检验值，由发送端计算和存储，由接收端校验。

- 数据, data
具体传输的数据


## 五. TCP 三次握手

![](/img/2020/TCP_three_handle.png)

#### 1. 握手目的
TCP 是面向连接的，一对一的，双向同时通信的可靠协议，必须在通信前，让 Client 和 Server 确认自己和对方的发送和接收通道正常。


#### 2. 握手过程

- 第一次握手：
	(1). Client 向 Server 发起连接请求，标志位 SYN = 1，序列号 Seq = x (一般是 0)；
	(2). Client 发送完毕后进入 SYN_SENT 状态，等待 Server 确认。
- 第二次握手：
	(1). Server 收到 Client 发起的标志位 SYN = 1 的连接请求后，返回一个确认响应，Flags 标志 SYN=1，ACK=1，序列号 Seq = y (一般是 0)，确认号 Ack = x + 1 ( Client 发送的序列号 Seq + 1)；
	(2). Server 发送完毕后进入 SYN_RCVD 状态，等待 Client 回应。
- 第三次握手：
	(1). Client 收到 Server 返回的标志位 SYN = 1 响应后，检查返回的标志位 ACK = 1，以及确认号 Ack 是否等于第一次握手发送的序列号 Seq + 1，即 x + 1
	(2). 如果正确，那么 Client 返回一个响应给 Server ，标志位 ACK=1，确认号 Ack = y + 1 ( Server 发送的序列号 Seq + 1)
	(3). Client 发送完毕后，进入 ESTABLISHED 状态，准备开始发送数据给 Server。
	(4). Server 收到 Client 返回的标志位 ACK=1 响应后，检查确认号 Ack 是否等于第二次握手发送的序列号 Seq + 1，即 y + 1
	(5). 如果正确，那么 Server 进入 ESTABLISHED 状态，准备接受 Client 的数据。


#### 3. 为啥三次握手： 让 Client 和 Server 确认自己和对方的发送和接收通道都正常。

- 第一次握手，Server 收到了 Client 的连接请求，此时 Server 知道 Client 发送的通道正常，也知道自己的接收通道正常
- 第二次握手，Client 收到了 Server 的响应和连接请求，此时 Client 知道自己的发送和接收通道都正常，也知道 Server 的发送和接收通道都正常。
- 第三次握手，Server 收到了 Client 的响应，此时 Server 知道自己的发送通道正常，也知道 Client 接收的通道也正常


分类| 第一次握手 | 第二次握手| 第三次握手
-|-|-|-
Server 确认 Client 发送正常|Y|-|-
Server 确认 Server 接收正常|Y|-|-
Client 确认 Client 发送正常|-|Y|-
Client 确认 Client 接收正常|-|Y|-
Client 确认 Server 发送正常|-|Y|-
Client 确认 Server 接收正常|-|Y|-
Server 确认 Client 接收正常|-|-|Y
Server 确认 Server 发送正常|-|-|Y


#### 4. SYN 攻击

- 在第二次握手时，Server 在发送 SYN-ACK 给 Client 之后，会进入 SYN_RCVD 状态；当收到 Client 响应的 ACK 后，即第三次握手时，Server 才转入 ESTABLISHED 状态。
- SYN 攻击就是 Client 在短时间内伪造大量不存在的IP地址，并向 Server 不断地发送 SYN 连接请求，Server 回复 ACK 确认包后，并等待 Client 的确认。
- 由于IP源地址是不存在的，因此 Server 需要不断重发直至超时，这些伪造的 SYN 请求将会占用未连接的队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。
- SYN 攻击是一种典型的 DDOS 攻击，检测 SYN 攻击的方式主要通过查看 Server 是否有大量半连接状态且源IP地址是随机的

```shell
netstat -nap | grep SYN_RECV

```

## 六. TCP 四次挥手


![](/img/2020/TCP_bye_one.jpg)

#### 1. 挥手目的：
TCP 是双向同时通信的协议，当 Server 和 Client 之间的数据发送完毕后，需要结束两端的连接通道。

#### 2. 挥手过程：

- 第一次挥手：
	(1). Client 发送结束请求给 Server，标志位 FIN = 1，序列号 Seq = x 请求，表示 Client 关闭了 Client 到 Server 的数据传送通道；
	(2). Client 发送完毕后，进入 FIN_WAIT_1 状态。
- 第二次挥手：
	(1). Server 收到 Client 标志位 FIN = 1 的结束请求后，发送响应给 Client，标志位 ACK = 1，确认号 Ack = x + 1（ Client 发送的序列号 Seq + 1 ）；
	(2). Server 发送完毕后，进入 CLOSE_WAIT 状态，此时 Server 依然可以给 Client 发送数据。
	(3). Client 收到 Server 的结束确认后，检查标志 ACK = 1 且 Ack = x + 1，如果正确，则进入 FIN_WAIT_2 状态。
- 第三次挥手：
	(1). Server 发送所有数据给 Client 后，最终会发送结束请求给 Client，标志位 FIN = 1，序列号 Seq = y，表示 Server 关闭了 Server 到 Client 的数据传送通道；
	(2). Server 发送完毕后，进入 LAST_ACK 状态。
- 第四次挥手：
	(1). Client 收到 Server 标志 FIN = 1 的结束请求后，接着发回响应给 Server，标志位 ACK = 1 ，确认号 Ack = y + 1 （ Server 发送的序列号 Seq + 1 ）；
	(2). Client 发送完毕后，进入 TIME_WAIT 状态，此过程将会持续 2MSL，即两倍最长报文时间 Maximum Segment Lifetime，之后 Client 才进入 CLOSED 状态。
	(3). Server 收到 Client 的结束确认后，检查标志位 ACK = 1 且 Ack = y + 1，如果正确，则进入 CLOSED 状态。



#### 3. 为啥四次挥手：确保 Server 和 Client 两端的连接都结束。
- 三次握手过程中，第二次握手时，Server 将 Client 连接请求的确认标志位 ACK 和允许建立连接的标志位 SYN 与一起发送给 Client。
- 四次挥手过程中，Server 在收到 Client 的结束请求 FIN 后，可能还有数据要发送，所以会首先响应一个 ACK 给 Client，等数据全部发送完毕后，再发送一个 FIN 给 Client
- Client 发送自己连接的 FIN， Client 发送 ACK 响应 Server 的 FIN，发生了两次挥手。
- Server 发送自己连接的 FIN， Server 发送 ACK 响应 Client 的 FIN，也发送了两次挥手，所以一共就四次挥手
- 如果 Server 响应 Client 的 ACK 和自己结束的 FIN 一起发送给 Client，那么其实三次挥手就能完成了。



分类| 第一次挥手 | 第二次挥手| 第三次挥手|第四次挥手
-|-|-|-|-
Client 发起 Client 通道结束请求|Y|-|-|-
Server 响应 Client 通道结束请求|-|Y|-|-
Server 发起 Server 通道结束请求|-|-|Y|-
Client 响应 Server 通道结束请求|-|-|-|Y

![](/img/2020/TCP_bye_two.png)



#### 4. 为啥 TIME_WAIT = 2MSL ( 最长报文时间 Maximum Segment Lifetime )

- 确保最后一个 Client 确认结束报文 ACK 能够到达 Server，两端通道都可靠地结束。
	(1). 如果 Server 没收到 Client 发送来的确认报文，那么就会重新发送一次结束请求；
	(2). 如果此时 Client 处于 CLOSED 状态，那么 Server 将会受到 Client 标志位 RST = 1 的报文，表示需要重建已经错乱了的连接。
	(3). 而 Client 在状态 TIME_WAIT，依然能够接受确认报文，等待一段时间就是为了处理 Server 重发结束请求的情况。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，避免端口相同的前后两个连接的报文混乱。
	(1). TCP 连接是根据端口区分不同连接的
	(2). 如果旧连接的数据在网络延迟才收到，而新连接使用了相同的端口，那么 Server 会以为相同的连接，那么旧连接的报文和新连接的报文就会混在一起了。
	(3). Client 等待两倍最长报文时间 Maximum Segment Lifetime，就是为了确保旧连接的报文，在网络中消失。


RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等



## TCP粘包、拆包

#### 1. UDP 是基于报文发送的，一个 UDP 报文就是完整的数据，UDP 首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

#### 2. TCP 粘包、拆包的原因
- TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；
- TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。


#### 3. TCP 粘包、拆包的场景
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

![](/img/2020/TCP_pkg_one.jpg)
![](/img/2020/TCP_pkg_three.jpg)
![](/img/2020/TCP_pkg_two.jpg)


#### 4. TCP粘包、拆包的解决办法
由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决。

- 消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- 设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
- 将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。
- 更复杂的应用层协议，比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。

